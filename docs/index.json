[{"categories":null,"content":"遇到的坑 假设接口resp响应如下，我们要提取里面的sessionId ，因为resp里面包含\\字符。所以需要在\\前面加\\形成\\\\才能正确提取 { \"status\": \"success\", \"data\": \"{\\\"title\\\":\\\"\\\",\\\"sessionName\\\":\\\"zentaosid\\\",\\\"sessionID\\\":\\\"qr4taa6q43evbder1iistqre5u\\\",\\\"rand\\\":100,\\\"pager\\\":null}\", \"md5\": \"4a199d04a0a2df3376e67213957a1347\" } ","date":"2023-04-12","objectID":"/postman/:0:1","tags":null,"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用字面量正则提取 /\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ resp = pm.response.text(); console.log(\"提取的resp为:\",resp); sessionId = resp.match(/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/)[1]; // 设置为全局变量 pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:2","tags":null,"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用构造函数正则 sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\" resp = pm.response.text(); console.log(\"提取的resp为:\",resp); pt = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",'); console.log(\"正则为:\",pt.toString()); sessionId = resp.match(pt)[1]; pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:3","tags":null,"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"后记 MDN上说： 当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。 以下是等价的 var re = new RegExp(\"\\\\w+\"); var re = /\\w+/; 就是说如果使用了元字符 比如 \\W、\\S之类的 字面量正则里面不需要加\\转义，比如：/\\w+/，构造函数就需要写成这种： pattern = new RegExp(\"\\\\w+\") 但如果正则里面包含$, (, ), *, +, ., [, ], ?, \\, ^, {, }, |。则 字面量正则需要加\\转义。如/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 构造函数正则需要加\\\\\\，也就是三个\\。 因为 pattern = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",') pattern_str = pattern.toString() // 输出结果为 /sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 而字符串的match函数接受的是一个字面量正则，如果你写成 pattern = new RegExp('sessionID\\\\\":\\\\\"(.*?)\\\\\",') pattern.toString()后会是/sessionID\\\":\\\"(.*?)\\\"/，匹配结果为null。 故 在postman中使用正则提取变量，如果你的接口响应里存在转义字符，还是使用字面量正则好一些。 ","date":"2023-04-12","objectID":"/postman/:0:4","tags":null,"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"需求 在yaml中需要引用自定义变量，我们参照 postman，约定变量符号为 {{}}。 思路 我们知道在 python 中字符串格式化可以通过 .format() 方法来处理。 比如 \u003e\u003e\u003e name = lee \u003e\u003e\u003e \"i am {}\".format(name) i am lee 但我们所需字符串中约定的变量符号为 {{}} ，因此源码的 format 方法是不行的，为此我们可以重写字符串的 format 方法来达到我们的需求。 继承 UserString 重写其 format 方法即可 import re from collections import UserString class String(UserString): def __init__(self, seq: object): super().__init__(seq) def format(self, /, **kwds) -\u003e str: pattern_param = r\"{{(\\w+)}}\" if params := list(set(re.findall(pattern_param, self.data))): for param in params: if value := kwds.get(param, \"\"): rex = f\"{{param}}\" self.data = re.sub(rex, str(value), self.data) return self.data 测试 \u003e\u003e\u003e d = {\"a\": 1, \"b\": 2} \u003e\u003e\u003e String(\"{hello, {{a}}, world {{b}}}\").format(**d) {hello, 1, world 2} 额外知识 看源码的时候我纳闷 format 的参数定义怎么是这样的。 def format(self, /, *args, **kwds): return self.data.format(*args, **kwds) 怎么有一个形参是/，难道通过/传参？心里想不可能吧。网上搜又不好搜。结果今儿无意中刷到了数据派THU的一条微博。我点开来一看，woc这不是我前几天遇到的问题嘛！ 真的是out了。 最后研究了一下，其实是python3.8的新特性。👉 Python 3.8 有什么新变化？ 它加了一个新特性：仅限位置形参 ( positional-only arguments )。 具体解释如下： ","date":"2023-04-11","objectID":"/strings-replace/:0:0","tags":null,"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"仅限位置形参 定义函数的形参时可以指定两个分隔符，分别为/， *。 在下面的例子中，形参 a 和 b 为仅限位置形参，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参。 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 以下均为合法的调用: f(10, 20, 30, d=40, e=50, f=60) 但是，以下均为不合法的调用: f(10, b=20, c=30, d=40, e=50, f=60) # b cannot be a keyword argument f(10, 20, 30, 40, 50, f=60) # e must be a keyword argument 这种标记形式的一个用例是它允许纯 Python 函数完整模拟现有的用 C 代码编写的函数的行为。 例如，内置的 divmod() 函数不接受关键字参数: def divmod(a, b, /): \"Emulate the built in divmod() function\" return (a // b, a % b) 另一个用例是在不需要形参名称时排除关键字参数。 例如，内置的 len() 函数的签名为 len(obj, /)。 这可以排除如下这种笨拙的调用形式: len(obj='hello') # The \"obj\" keyword argument impairs readability 另一个益处是将形参标记为仅限位置形参将允许在未来修改形参名而不会破坏客户的代码。 例如，在 statistics 模块中，形参名 dist 在未来可能被修改。 这使得以下函数描述成为可能: def quantiles(dist, /, *, n=4, method='exclusive') ... 由于在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用: \u003e\u003e\u003e \u003e\u003e\u003e def f(a, b, /, **kwargs): ... print(a, b, kwargs) ... \u003e\u003e\u003e f(10, 20, a=1, b=2, c=3) # a and b are used in two ways 10 20 {'a': 1, 'b': 2, 'c': 3} 这极大地简化了需要接受任意关键字参数的函数和方法的实现。 例如，以下是一段摘自 collections 模块的代码: class Counter(dict): def __init__(self, iterable=None, /, **kwds): # Note \"iterable\" is a possible keyword argument。 还有几个特性： 赋值表达式，也叫海象运算符: :=。 # Loop over fixed length blocks while (block := f.read(256)) != '': process(block) f-string = 用于自动记录表达式和调试文档，也就是加个=直接输出值。 \u003e\u003e\u003e user = 'eric_idle' \u003e\u003e\u003e member_since = date(1975, 7, 31) \u003e\u003e\u003e f'{user=} {member_since=}' ... \"user='eric_idle' member_since=datetime.date(1975, 7, 31)\" 其他的参考官方文档。 参考链接 Python 3.8 有什么新变化 ","date":"2023-04-11","objectID":"/strings-replace/:0:1","tags":null,"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"看了很多博主写的文章，感觉解释的不是很详细，本文结合实际操作详细记录了个人对于read、readline、readlines用法的剖解过程。 函数解释及区别 ","date":"2023-04-11","objectID":"/requests/:0:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取全部内容（即不指定n），返回字符串。 函数原型 def read(self, n: int = -1) -\u003e AnyStr: pass 默认读取整个文件，但有以下区别： 返回值的类型是字符串。 读取的最小单位为字符数 最大读取取决于n。 最小读取取决于n。 ","date":"2023-04-11","objectID":"/requests/:1:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取一行内容（即不指定limit）返回一个字符串。 函数原型 def readline(self, limit: int = -1) -\u003e AnyStr: pass 与readlines字面意思一样，也是按行读取，但有以下区别： 返回值的类型是字符串。 最小读取单位为字符数 最小读取取决于limit 最大读取为一行 ","date":"2023-04-11","objectID":"/requests/:2:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取所有内容（即不指定hint），按行返回一个列表，一行内容作为列表的一个元素。 函数原型 def readlines(self, hint: int = -1) -\u003e List[AnyStr]: pass 与readline字面意思一样，也是按行读取，但有以下区别： 返回值的类型是列表。 最小读取单位为行。 最大读取取决于hint。 最小读取为一行。 实际操作 假设有以下文本内容 hello world1 hello world2 hello world3 hello world4 hello world5 hello world6 hello world7 ","date":"2023-04-11","objectID":"/requests/:3:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\nhello world2\\nhello world3\\nhello world4\\nhello world5\\nhello world6\\nhello world7' 一次读取10个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read(10) if __name__ == '__main__': print(repr(load())) # 输出 'hello worl' ","date":"2023-04-11","objectID":"/requests/:4:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 指定一次读取2个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(2) if __name__ == '__main__': print(repr(load())) # 输出 'he' 指定一次读取15个字符， 可以猜一下输出什么？ hello world1\\nhe? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(15) if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 可以看到并没有将第二行读取进来，也印证了上面我们说： readline 最大读取为一行，最小读取取决于limit。 ","date":"2023-04-11","objectID":"/requests/:5:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines() if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n', 'hello world3\\n', 'hello world4\\n', 'hello world5\\n', 'hello world6\\n', 'hello world7'] 指定一次读取5个字符，猜一猜输出什么？ ['hello'] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(5) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n'] 并没有。 readlines 最小读取为一行。 指定一次读取15个字符，猜一猜输出什么？ [‘hello world1\\nhe’] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(15) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n'] 并没有，它读取了两行。 当字符数不够一行时，会将剩余字符一起读进来。所以readlines 的最小读取单位为行。 ","date":"2023-04-11","objectID":"/requests/:6:0","tags":null,"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"关于我","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"😁关于我 我叫cuckooman，是一名立志成为全栈工程师的测试开发工程师。 这是个人在工作之余记录并分享知识的博客，主要涉及测试专业方向，求职简历、一些软件技巧知识、个人生活记录等。 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"🐱‍🚀社交平台 gitee: https://gitee.com/lee_yorke csdn: https://blog.csdn.net/weixin_44200553 个人博客: https://leeyorke.github.io/ ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"}]