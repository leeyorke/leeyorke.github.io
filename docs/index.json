[{"categories":["python"],"content":"最近在研究 python 文件读取的时候，发现有人这么写代码，说这个 read(n) 函数里面的形参 n 是字节的意思，但其实这个 n 真正的意思是字符个数，所以有些文章可能有些误导。 with open(r'/usr/demo.txt', 'r', encoding='utf-8') as f: file = f.read(1024*1024) 存储单位换算关系 单位 关系 说明 bit（binary digit）比特 这是表示信息的最小单位，它只能表示 0 或 1。 byte（字节）B 1 byte (B) = 8 bit，一个英文字母1字节 其表示的值范围是0 ~ 255(无符号) 或 -127~127(有符号)，而一个汉字的占两个字节，因为8 bit 不够 KB（Kilobyte） 1 KB = 1024 byte Megabyte 1 MB = 1024 KB Gigabyte 1 GB = 1024 MB Terabyte 1 TB = 1024 GB 不同类型字符所占字节大小的区别 在Unicode编码中，一个英文字符占1 bytes，一个汉字占2 bytes。 但一个文本里面,语言的不同也会影响单个字符所占字节大小。 文本构成 单个字符所占字节大小 英文、\\n、\\t 1 汉字、\\n、\\t 2 英文、汉字、\\n、\\t 2 故，按照上面的换算关系： 如果是纯英文文本，一次读取 1024*1024 个字符，实际上就是一次读取1 MB； 但如果文本包含中文，一次读取 1024*1024 个字符就不是1 MB了，实际是1024*1024*2 byte, 就是2 MB了。 所以这个 n 真正的意思是字符个数。 ","date":"2023-04-14","objectID":"/python-func-read/:0:0","tags":["python","字节"],"title":"python | read 函数","uri":"/python-func-read/"},{"categories":null,"content":"普鲁斯特问卷｜人生35问","date":"2023-04-13","objectID":"/about/proust/","tags":["关于"],"title":"普鲁斯特问卷｜人生35问","uri":"/about/proust/"},{"categories":null,"content":"01 What is your idea of perfect happiness ? 你认为最完美的幸福是怎样的？ 包容性的社会，尊重子女但懂得追求自身幸福的父母，勇敢并为理想奋不顾身的我。 02 What is your greatest fear ? 你最大的恐惧是什么？ 退缩 03 What is the trait you most deplore in yourself ? 你最痛恨自己的哪些特质？ 不自信，不勇敢 04 What is the trait you most deplore in others ? 你最痛恨别人的什么特点？ 不真诚，不尊重他人 05 Which living person do you most admire ? 还在世的人中你最欣赏的是谁？ 很难说最欣赏谁，我欣赏纯粹的，做事认真，奋不顾身的人 06 What is your greatest extravagance ? 你最大的奢侈品是什么？ 只有年龄 07 What is your current state of mind ? 你目前的心境怎样？ 期待并正在努力美好的未来，但生活处处是遗憾，期望自己能够赶快变得更强大些 08 What do you consider the most overrated virtue ? 你认为哪种美德是被过高评价的？ 孔融让梨 09 On what occasion do you lie ? 什么情况下你会撒谎？ 报喜不报忧的时候 10 What do you most dislike about your appearance ? 你对自己的外表哪一点不满意？ 鼻子，颧骨 11 Which living person do you most despise ? 还在世的人中你最鄙视谁？ 没有 12 What is the quality you most like in a man ? 你最喜欢男性身上的什么品质？ 勇敢 13 What is the quality you most like in a woman ? 你最喜欢女性身上的什么品质？ 知性 14 Which words or phrases do you most overuse ? 你最常使用的单词或短语是什么？ “国粹” 15 What or who is the greatest love of your life ? 你这一生中最伟大的爱是谁/什么？ who：父亲 what：科学与艺术 16 When and where were you happiest ? 何时何地让你感觉到最快乐？ 童年在玉米地里玩捉迷藏的时候。 高中和喜欢的人互相聊天的时候。 平日里看电影哭的稀里哗啦的时候。 写出某个自认为厉害的作品的时候。 17 Which talent would you most like to have ? 你最想拥有哪种才能？ 太多了 作曲：为电影配乐 英语：交流 航海：环游世界 穿越 18 If you could change one thing about yourself, what would it be ? 如果你能够改变自己的一件事，那会是什么？ 让我成为勇敢的人 19 What do you consider your greatest achievement ? 你认为自己最大的成就是什么？ 迷惘中夹杂着一丝清醒 20 If you were to die and come back as a person or a thing, what would it be ? 如果有转世，你希望成为什么样的人或物？ 一个作家 21 Where would you most like to live ? 你最想住在哪里？ 伊犁 22 What is your most treasured possession ? 你最珍贵的财产是什么？ 伸手可触的电影，文学和音乐 23 What do you regard as the lowest depth of misery ? 你认为程度最浅的痛苦是什么？ 孤独 24 What is your favorite occupation ? 你最喜欢的职业是什么？ 冒险家 25 What is your most marked characteristic ? 你最显著的特点是什么？ 安静 26 What do you most value in your friends ? 你最看重朋友的什么特点？ 真诚，认真，执着 27 Who are your favorite writers ? 你最喜欢的作家是谁？ 梭罗 28 Who is your hero of fiction ? 谁是你心目中小说里的英雄？ 冉阿让 29 Which historical figure do you most identify with ? 你最认同哪位历史人物？ 黑格尔 30 Who are your heroes in real life ? 谁是你现实生活中的英雄？ 暂没遇到 31 What are your favorite names ? 你最喜欢的名字是什么？ 暂时没想到 32 What is it that you most dislike ? 你最不喜欢什么？ 渺小而不自知 33 What is your greatest regret ? 你最大的遗憾是什么？ 不勇敢，不拼尽全力 34 How would you like to die ? 你想以何种方式死去？ 在一个阳光明媚的旅途中，听着莫里康内的 overture 35 What is your motto ? 你的座右铭是什么？ 持续学习，心存理想，浪漫勇敢 ","date":"2023-04-13","objectID":"/about/proust/:0:0","tags":["关于"],"title":"普鲁斯特问卷｜人生35问","uri":"/about/proust/"},{"categories":null,"content":"遇到的坑 假设接口resp响应如下，我们要提取里面的sessionId ，因为resp里面包含\\字符。所以需要在\\前面加\\形成\\\\才能正确提取 { \"status\": \"success\", \"data\": \"{\\\"title\\\":\\\"\\\",\\\"sessionName\\\":\\\"zentaosid\\\",\\\"sessionID\\\":\\\"qr4taa6q43evbder1iistqre5u\\\",\\\"rand\\\":100,\\\"pager\\\":null}\", \"md5\": \"4a199d04a0a2df3376e67213957a1347\" } ","date":"2023-04-12","objectID":"/postman/:0:1","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用字面量正则提取 /\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ resp = pm.response.text(); console.log(\"提取的resp为:\",resp); sessionId = resp.match(/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/)[1]; // 设置为全局变量 pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:2","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用构造函数正则 sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\" resp = pm.response.text(); console.log(\"提取的resp为:\",resp); pt = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",'); console.log(\"正则为:\",pt.toString()); sessionId = resp.match(pt)[1]; pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:3","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"后记 MDN上说： 当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。 以下是等价的 var re = new RegExp(\"\\\\w+\"); var re = /\\w+/; 就是说如果使用了元字符 比如 \\W、\\S之类的 字面量正则里面不需要加\\转义，比如：/\\w+/，构造函数就需要写成这种： pattern = new RegExp(\"\\\\w+\") 但如果正则里面包含$, (, ), *, +, ., [, ], ?, \\, ^, {, }, |。则 字面量正则需要加\\转义。如/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 构造函数正则需要加\\\\\\，也就是三个\\。 因为 pattern = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",') pattern_str = pattern.toString() // 输出结果为 /sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 而字符串的match函数接受的是一个字面量正则，如果你写成 pattern = new RegExp('sessionID\\\\\":\\\\\"(.*?)\\\\\",') pattern.toString()后会是/sessionID\\\":\\\"(.*?)\\\"/，匹配结果为null。 故 在postman中使用正则提取变量，如果你的接口响应里存在转义字符，还是使用字面量正则好一些。 ","date":"2023-04-12","objectID":"/postman/:0:4","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"需求 在yaml中需要引用自定义变量，我们参照 postman，约定变量符号为 {{}}。 思路 我们知道在 python 中字符串格式化可以通过 .format() 方法来处理。 比如 \u003e\u003e\u003e name = lee \u003e\u003e\u003e \"i am {}\".format(name) i am lee 但我们所需字符串中约定的变量符号为 {{}} ，因此源码的 format 方法是不行的，为此我们可以重写字符串的 format 方法来达到我们的需求。 继承 UserString 重写其 format 方法即可 import re from collections import UserString class String(UserString): def __init__(self, seq: object): super().__init__(seq) def format(self, /, **kwds) -\u003e str: pattern_param = r\"{{(\\w+)}}\" if params := list(set(re.findall(pattern_param, self.data))): for param in params: if value := kwds.get(param, \"\"): rex = f\"{{param}}\" self.data = re.sub(rex, str(value), self.data) return self.data 测试 \u003e\u003e\u003e d = {\"a\": 1, \"b\": 2} \u003e\u003e\u003e String(\"{hello, {{a}}, world {{b}}}\").format(**d) {hello, 1, world 2} 额外知识 看源码的时候我纳闷 format 的参数定义怎么是这样的。 def format(self, /, *args, **kwds): return self.data.format(*args, **kwds) 怎么有一个形参是/，难道通过/传参？心里想不可能吧。网上搜又不好搜。结果今儿无意中刷到了数据派THU的一条微博。我点开来一看，woc这不是我前几天遇到的问题嘛！ 真的是out了。 最后研究了一下，其实是python3.8的新特性。👉 Python 3.8 有什么新变化？ 它加了一个新特性：仅限位置形参 ( positional-only arguments )。 具体解释如下： ","date":"2023-04-11","objectID":"/strings-replace/:0:0","tags":["python"],"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"仅限位置形参 定义函数的形参时可以指定两个分隔符，分别为/， *。 在下面的例子中，形参 a 和 b 为仅限位置形参，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参。 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 以下均为合法的调用: f(10, 20, 30, d=40, e=50, f=60) 但是，以下均为不合法的调用: f(10, b=20, c=30, d=40, e=50, f=60) # b cannot be a keyword argument f(10, 20, 30, 40, 50, f=60) # e must be a keyword argument 这种标记形式的一个用例是它允许纯 Python 函数完整模拟现有的用 C 代码编写的函数的行为。 例如，内置的 divmod() 函数不接受关键字参数: def divmod(a, b, /): \"Emulate the built in divmod() function\" return (a // b, a % b) 另一个用例是在不需要形参名称时排除关键字参数。 例如，内置的 len() 函数的签名为 len(obj, /)。 这可以排除如下这种笨拙的调用形式: len(obj='hello') # The \"obj\" keyword argument impairs readability 另一个益处是将形参标记为仅限位置形参将允许在未来修改形参名而不会破坏客户的代码。 例如，在 statistics 模块中，形参名 dist 在未来可能被修改。 这使得以下函数描述成为可能: def quantiles(dist, /, *, n=4, method='exclusive') ... 由于在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用: \u003e\u003e\u003e \u003e\u003e\u003e def f(a, b, /, **kwargs): ... print(a, b, kwargs) ... \u003e\u003e\u003e f(10, 20, a=1, b=2, c=3) # a and b are used in two ways 10 20 {'a': 1, 'b': 2, 'c': 3} 这极大地简化了需要接受任意关键字参数的函数和方法的实现。 例如，以下是一段摘自 collections 模块的代码: class Counter(dict): def __init__(self, iterable=None, /, **kwds): # Note \"iterable\" is a possible keyword argument。 还有几个特性： 赋值表达式，也叫海象运算符: :=。 # Loop over fixed length blocks while (block := f.read(256)) != '': process(block) f-string = 用于自动记录表达式和调试文档，也就是加个=直接输出值。 \u003e\u003e\u003e user = 'eric_idle' \u003e\u003e\u003e member_since = date(1975, 7, 31) \u003e\u003e\u003e f'{user=} {member_since=}' ... \"user='eric_idle' member_since=datetime.date(1975, 7, 31)\" 其他的参考官方文档。 参考链接 Python 3.8 有什么新变化 ","date":"2023-04-11","objectID":"/strings-replace/:0:1","tags":["python"],"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"看了很多博主写的文章，感觉解释的不是很详细，本文结合实际操作详细记录了个人对于read、readline、readlines用法的剖解过程。 函数解释及区别 ","date":"2023-04-11","objectID":"/requests/:0:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取全部内容（即不指定n），返回字符串。 函数原型 def read(self, n: int = -1) -\u003e AnyStr: pass 默认读取整个文件，但有以下区别： 返回值的类型是字符串。 读取的最小单位为字符数 最大读取取决于n。 最小读取取决于n。 ","date":"2023-04-11","objectID":"/requests/:1:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取一行内容（即不指定limit）返回一个字符串。 函数原型 def readline(self, limit: int = -1) -\u003e AnyStr: pass 与readlines字面意思一样，也是按行读取，但有以下区别： 返回值的类型是字符串。 最小读取单位为字符数 最小读取取决于limit 最大读取为一行 ","date":"2023-04-11","objectID":"/requests/:2:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取所有内容（即不指定hint），按行返回一个列表，一行内容作为列表的一个元素。 函数原型 def readlines(self, hint: int = -1) -\u003e List[AnyStr]: pass 与readline字面意思一样，也是按行读取，但有以下区别： 返回值的类型是列表。 最小读取单位为行。 最大读取取决于hint。 最小读取为一行。 实际操作 假设有以下文本内容 hello world1 hello world2 hello world3 hello world4 hello world5 hello world6 hello world7 ","date":"2023-04-11","objectID":"/requests/:3:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\nhello world2\\nhello world3\\nhello world4\\nhello world5\\nhello world6\\nhello world7' 一次读取10个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read(10) if __name__ == '__main__': print(repr(load())) # 输出 'hello worl' ","date":"2023-04-11","objectID":"/requests/:4:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 指定一次读取2个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(2) if __name__ == '__main__': print(repr(load())) # 输出 'he' 指定一次读取15个字符， 可以猜一下输出什么？ hello world1\\nhe? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(15) if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 可以看到并没有将第二行读取进来，也印证了上面我们说： readline 最大读取为一行，最小读取取决于limit。 ","date":"2023-04-11","objectID":"/requests/:5:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines() if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n', 'hello world3\\n', 'hello world4\\n', 'hello world5\\n', 'hello world6\\n', 'hello world7'] 指定一次读取5个字符，猜一猜输出什么？ ['hello'] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(5) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n'] 并没有。 readlines 最小读取为一行。 指定一次读取15个字符，猜一猜输出什么？ [‘hello world1\\nhe’] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(15) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n'] 并没有，它读取了两行。 当字符数不够一行时，会将剩余字符一起读进来。所以readlines 的最小读取单位为行。 ","date":"2023-04-11","objectID":"/requests/:6:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"关于我","date":"2019-08-02","objectID":"/about/me/","tags":["关于"],"title":"关于我","uri":"/about/me/"},{"categories":null,"content":"😁关于我 我叫cuckooman。 1996 出生于陕西宝鸡的一个农村家庭，有个妹妹，爷爷奶奶在我三岁的时候就去世了， 因此相对别的发小来说没有体会过爷爷辈的关爱。父母都是很传统的农民，普普通通的四口之家。 目前是一名立志成为全栈工程师的测试开发工程师。主语言为 Python， 也写一些 shell，喜欢Linux、docker 这是个人在工作之余记录并分享知识的博客，主要涉及测试专业方向，求职简历、一些软件技巧知识、个人生活记录等。 ","date":"2019-08-02","objectID":"/about/me/:0:1","tags":["关于"],"title":"关于我","uri":"/about/me/"},{"categories":null,"content":"🐱‍🚀社交平台 gitee: https://gitee.com/lee_yorke csdn: https://blog.csdn.net/weixin_44200553 个人博客: https://leeyorke.github.io/ ","date":"2019-08-02","objectID":"/about/me/:0:2","tags":["关于"],"title":"关于我","uri":"/about/me/"}]