[{"categories":null,"content":"背景 在更新文件的时候，考虑到在文件头部加上 version 及 change 之类的东西，以此来区分文件的异同并且能保存旧文件。但在实际操作中遇到了以下问题。 utf-8 下一个汉字占2个字节，包括各种标点符号、空格、换行符；gbk下一个汉字占2个字节，标点符号没验证不知道。 在 python3 中用 sys.getsizeof() 计算文本的所占字节大小，是根据编码方式计算字节大小的。如果文本包含汉字，减去74是真实大小，如果文本是纯英文， 减去49是真实大小，这个是由于 UTF-8 BOM 头存在机制的原因。 在 python3 文件指针 fp.tell() 中，一个汉字及中文标点符号是按3字节来算的，空格为一个字节，换行符为两个字节，所以写偏移量的时候要注意。 python中的 IO 操作 一个简单的文本读取如下 with open(r'.\\test.txt', 'r', encoding='utf-8') as fp: print(fp.read()) ","date":"2023-04-18","objectID":"/python-file-operations/:0:0","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"01 f.seek() @abstractmethod def seek(self, offset: int, whence: int = 0) -\u003e int: pass offset：从 whence 开始，需要多少偏移量（必填参数），也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始； whence：从哪个位置开始偏移（可选参数），默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。 ","date":"2023-04-18","objectID":"/python-file-operations/:1:0","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"02 fp.tell() @abstractmethod def tell(self) -\u003e int: pass ","date":"2023-04-18","objectID":"/python-file-operations/:2:0","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"文件读取模式 python 中给出了多个文件读取模式符，但每个意思都有一些区别，以及各自的应用场景，为此我们需要理清各个字符所表达的含义。 类型 含义 r 只读 x 只写 w 只写 a 追写 r+ 可读可写 w+ 可读可写 a+ 可读可写 ","date":"2023-04-18","objectID":"/python-file-operations/:3:0","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"具体区别 ","date":"2023-04-18","objectID":"/python-file-operations/:4:0","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"r rt 的简写，即 r = rt，意为以文本模式读取，w、a 亦如此。 打开一个文件，只能进行读取操作，不能写； 默认读取位置从文件头部开始。 如果文件不存在，抛出异常。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:1","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"w 打开一个文件，只能进行写操作，不能读； 默认写入位置从文件头部开始； 如果文件存在，则直接开始写，覆盖原内容； 如果文件不存在，则创建这个文件然后开始写。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:2","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"x 打开一个文件，只能进行写操作，不能读； 默认写入位置从文件头部开始； 如果文件存在，抛出异常； 如果文件不存在，则先创建这个文件，然后开始写。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:3","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"a 打开一个文件，只能进行写操作，不能读； 默认写入位置从文件尾部开始； 如果文件不存在，则先创建这个文件，然后开始追加写。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:4","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"r+ 打开一个文件，进行读写操作； 默认写入位置从文件头部开始； 如果文件不存在，抛出异常。 如果写之前进行了读操作（读到哪里文件指针就指到哪里），无论读取多少内容，写入始终追加到文件末尾，我以为会是从文件指针后开始写，但是并没有，猜测写python源码的可能做了保护，考虑到在读的时候如果文件文件只读了一部分，那么中途写必将会覆盖原内容，而此时还有原内容未读，这时候就产生了冲突，所以在此模式下不管读取全部内容还是部分，写的时候强制将文件指针移动到文件末尾。； 如果写之前未进行读操作，则从头开始写入内容，并覆盖原内容，覆盖原内容的长度为写入内容的长度，如果写入内容与原内容语言不一致这时候坑就来了，比如写入是英文，原内容为中文，原内容为先生你好 （占12个字节），写入内容为 hello（占个5字节），「hello」不能够完全覆盖「中国你」，此时解释器就会抛出 UnicodeDecodeError。如果语言一致则不存在这个问题。 如果是先写后读，那么读取位置从写完内容后文件指针位置开始读取。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:5","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"w+ 打开一个文件，进行读写操作； 默认写入位置从文件头部开始； 如果文件不存在，则先创建这个文件。 写的优先级大于读 如果先读后写，那么读到的内容为空，因为他会先清空原文本，再开始重写整个文件。 如果先写后读，那么读到的内容也为空，因为写完后文件指针已处于文件末尾，此时读取为空。如果要读，那么需要通过 fp.seek() 改变文件指针指向。 ","date":"2023-04-18","objectID":"/python-file-operations/:4:6","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":null,"content":"a+ 打开一个文件，进行读写操作； 默认写入位置从文件尾部开始； 如果文件不存在，则先创建这个文件。 如果先读后写，那么读到的内容为空，因为a 模式文件初始指针指向在文件末尾，对于写，内容直接追加到文件末尾。 如果先写后读，对于写，内容直接追加到文件末尾。对于读，读到的内容也为空，因为写完后文件指针已处于文件末尾，此时读取为空。如果要读，那么需要通过 fp.seek() 改变文件指针指向。 应用场景 类型 应用场景 r 只需要进行读文件的时候 x 只需要进行创建文件的时候 w 只需要进行读文件的时候 a 只需要在文件后追加内容的时候 r+ 读、覆写、先读后追加、插入 w+ 覆写、创建文件、插入 a+ 追加、创建文件、插入 实际上有 + 的模式都可以利用改变文件指针的方式来进行读、覆写、追加、插入，但还是建议按官方使用规范来。 解决 那么如何插入文本到文件头部？ with open(r'test.txt', 'r+', encoding='utf-8') as fp: insert_content = \"insert_words\" content = fp.read() fp.seek(0, 0) # 将文件指针移动到文件头部 fp.write(f'{insert_content}\\n'+content) ","date":"2023-04-18","objectID":"/python-file-operations/:4:7","tags":null,"title":"python | 文件的 IO 操作你真的精通吗","uri":"/python-file-operations/"},{"categories":["python"],"content":"最近在研究 python 文件读取的时候，发现有人这么写代码，说这个 read(n) 函数里面的形参 n 是字节的意思，但其实这个 n 真正的意思是字符个数，所以有些文章可能有些误导。 with open(r'/usr/demo.txt', 'r', encoding='utf-8') as f: file = f.read(1024*1024) 存储单位换算关系 单位 关系 说明 bit（binary digit）比特 这是表示信息的最小单位，它只能表示 0 或 1。 byte（字节）B 1 byte (B) = 8 bit，一个英文字母1字节 其表示的值范围是0 ~ 255(无符号) 或 -127~127(有符号)，而一个汉字的占两个字节，因为8 bit 不够 KB（Kilobyte） 1 KB = 1024 byte Megabyte 1 MB = 1024 KB Gigabyte 1 GB = 1024 MB Terabyte 1 TB = 1024 GB 不同类型字符所占字节大小的区别 在Unicode编码中，一个英文字符占1 bytes，一个汉字占2 bytes。 但一个文本里面,语言的不同也会影响单个字符所占字节大小。 文本构成 单个字符所占字节大小 英文、\\n、\\t 1 汉字、\\n、\\t 2 英文、汉字、\\n、\\t 2 故，按照上面的换算关系： 如果是纯英文文本，一次读取 1024*1024 个字符，实际上就是一次读取1 MB； 但如果文本包含中文，一次读取 1024*1024 个字符就不是1 MB了，实际是1024*1024*2 byte, 就是2 MB了。 所以这个 n 真正的意思是字符个数。 ","date":"2023-04-14","objectID":"/python-func-read/:0:0","tags":["python","字节"],"title":"python | read 函数","uri":"/python-func-read/"},{"categories":null,"content":"普鲁斯特问卷｜人生35问","date":"2023-04-13","objectID":"/about/proust/","tags":["关于"],"title":"普鲁斯特问卷｜人生35问","uri":"/about/proust/"},{"categories":null,"content":"01 What is your idea of perfect happiness ? 你认为最完美的幸福是怎样的？ 包容性的社会，尊重子女但懂得追求自身幸福的父母，勇敢并为理想奋不顾身的我。 02 What is your greatest fear ? 你最大的恐惧是什么？ 退缩 03 What is the trait you most deplore in yourself ? 你最痛恨自己的哪些特质？ 不自信，不勇敢 04 What is the trait you most deplore in others ? 你最痛恨别人的什么特点？ 不真诚，不尊重他人 05 Which living person do you most admire ? 还在世的人中你最欣赏的是谁？ 很难说最欣赏谁，我欣赏纯粹的，做事认真，奋不顾身的人 06 What is your greatest extravagance ? 你最大的奢侈品是什么？ 只有年龄 07 What is your current state of mind ? 你目前的心境怎样？ 期待并正在努力美好的未来，但生活处处是遗憾，期望自己能够赶快变得更强大些 08 What do you consider the most overrated virtue ? 你认为哪种美德是被过高评价的？ 孔融让梨 09 On what occasion do you lie ? 什么情况下你会撒谎？ 报喜不报忧的时候 10 What do you most dislike about your appearance ? 你对自己的外表哪一点不满意？ 鼻子，颧骨 11 Which living person do you most despise ? 还在世的人中你最鄙视谁？ 没有 12 What is the quality you most like in a man ? 你最喜欢男性身上的什么品质？ 勇敢 13 What is the quality you most like in a woman ? 你最喜欢女性身上的什么品质？ 知性 14 Which words or phrases do you most overuse ? 你最常使用的单词或短语是什么？ “国粹” 15 What or who is the greatest love of your life ? 你这一生中最伟大的爱是谁/什么？ who：父亲 what：科学与艺术 16 When and where were you happiest ? 何时何地让你感觉到最快乐？ 童年在玉米地里玩捉迷藏的时候。 高中和喜欢的人互相聊天的时候。 平日里看电影哭的稀里哗啦的时候。 写出某个自认为厉害的作品的时候。 17 Which talent would you most like to have ? 你最想拥有哪种才能？ 太多了 作曲：为电影配乐 英语：交流 航海：环游世界 穿越 18 If you could change one thing about yourself, what would it be ? 如果你能够改变自己的一件事，那会是什么？ 让我成为勇敢的人 19 What do you consider your greatest achievement ? 你认为自己最大的成就是什么？ 迷惘中夹杂着一丝清醒 20 If you were to die and come back as a person or a thing, what would it be ? 如果有转世，你希望成为什么样的人或物？ 一个作家 21 Where would you most like to live ? 你最想住在哪里？ 伊犁 22 What is your most treasured possession ? 你最珍贵的财产是什么？ 伸手可触的电影，文学和音乐 23 What do you regard as the lowest depth of misery ? 你认为程度最浅的痛苦是什么？ 孤独 24 What is your favorite occupation ? 你最喜欢的职业是什么？ 冒险家 25 What is your most marked characteristic ? 你最显著的特点是什么？ 安静 26 What do you most value in your friends ? 你最看重朋友的什么特点？ 真诚，认真，执着 27 Who are your favorite writers ? 你最喜欢的作家是谁？ 梭罗 28 Who is your hero of fiction ? 谁是你心目中小说里的英雄？ 冉阿让 29 Which historical figure do you most identify with ? 你最认同哪位历史人物？ 黑格尔 30 Who are your heroes in real life ? 谁是你现实生活中的英雄？ 暂没遇到 31 What are your favorite names ? 你最喜欢的名字是什么？ 暂时没想到 32 What is it that you most dislike ? 你最不喜欢什么？ 渺小而不自知 33 What is your greatest regret ? 你最大的遗憾是什么？ 不勇敢，不拼尽全力 34 How would you like to die ? 你想以何种方式死去？ 在一个阳光明媚的旅途中，听着莫里康内的 overture 35 What is your motto ? 你的座右铭是什么？ 持续学习，心存理想，浪漫勇敢 ","date":"2023-04-13","objectID":"/about/proust/:0:0","tags":["关于"],"title":"普鲁斯特问卷｜人生35问","uri":"/about/proust/"},{"categories":null,"content":"遇到的坑 假设接口resp响应如下，我们要提取里面的sessionId ，因为resp里面包含\\字符。所以需要在\\前面加\\形成\\\\才能正确提取 { \"status\": \"success\", \"data\": \"{\\\"title\\\":\\\"\\\",\\\"sessionName\\\":\\\"zentaosid\\\",\\\"sessionID\\\":\\\"qr4taa6q43evbder1iistqre5u\\\",\\\"rand\\\":100,\\\"pager\\\":null}\", \"md5\": \"4a199d04a0a2df3376e67213957a1347\" } ","date":"2023-04-12","objectID":"/postman/:0:1","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用字面量正则提取 /\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ resp = pm.response.text(); console.log(\"提取的resp为:\",resp); sessionId = resp.match(/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/)[1]; // 设置为全局变量 pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:2","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"使用构造函数正则 sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\" resp = pm.response.text(); console.log(\"提取的resp为:\",resp); pt = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",'); console.log(\"正则为:\",pt.toString()); sessionId = resp.match(pt)[1]; pm.globals.set(\"ssesionId\", sessionId); console.log(\"提取的sessionId为:\",sessionId); ","date":"2023-04-12","objectID":"/postman/:0:3","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"后记 MDN上说： 当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。 以下是等价的 var re = new RegExp(\"\\\\w+\"); var re = /\\w+/; 就是说如果使用了元字符 比如 \\W、\\S之类的 字面量正则里面不需要加\\转义，比如：/\\w+/，构造函数就需要写成这种： pattern = new RegExp(\"\\\\w+\") 但如果正则里面包含$, (, ), *, +, ., [, ], ?, \\, ^, {, }, |。则 字面量正则需要加\\转义。如/\"sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 构造函数正则需要加\\\\\\，也就是三个\\。 因为 pattern = new RegExp('sessionID\\\\\\\\\":\\\\\\\\\"(.*?)\\\\\\\\\",') pattern_str = pattern.toString() // 输出结果为 /sessionID\\\\\":\\\\\"(.*?)\\\\\"/ 而字符串的match函数接受的是一个字面量正则，如果你写成 pattern = new RegExp('sessionID\\\\\":\\\\\"(.*?)\\\\\",') pattern.toString()后会是/sessionID\\\":\\\"(.*?)\\\"/，匹配结果为null。 故 在postman中使用正则提取变量，如果你的接口响应里存在转义字符，还是使用字面量正则好一些。 ","date":"2023-04-12","objectID":"/postman/:0:4","tags":["测试"],"title":"postman脚本使用正则提取变量","uri":"/postman/"},{"categories":null,"content":"需求 在yaml中需要引用自定义变量，我们参照 postman，约定变量符号为 {{}}。 思路 我们知道在 python 中字符串格式化可以通过 .format() 方法来处理。 比如 \u003e\u003e\u003e name = lee \u003e\u003e\u003e \"i am {}\".format(name) i am lee 但我们所需字符串中约定的变量符号为 {{}} ，因此源码的 format 方法是不行的，为此我们可以重写字符串的 format 方法来达到我们的需求。 继承 UserString 重写其 format 方法即可 import re from collections import UserString class String(UserString): def __init__(self, seq: object): super().__init__(seq) def format(self, /, **kwds) -\u003e str: pattern_param = r\"{{(\\w+)}}\" if params := list(set(re.findall(pattern_param, self.data))): for param in params: if value := kwds.get(param, \"\"): rex = f\"{{param}}\" self.data = re.sub(rex, str(value), self.data) return self.data 测试 \u003e\u003e\u003e d = {\"a\": 1, \"b\": 2} \u003e\u003e\u003e String(\"{hello, {{a}}, world {{b}}}\").format(**d) {hello, 1, world 2} 额外知识 看源码的时候我纳闷 format 的参数定义怎么是这样的。 def format(self, /, *args, **kwds): return self.data.format(*args, **kwds) 怎么有一个形参是/，难道通过/传参？心里想不可能吧。网上搜又不好搜。结果今儿无意中刷到了数据派THU的一条微博。我点开来一看，woc这不是我前几天遇到的问题嘛！ 真的是out了。 最后研究了一下，其实是python3.8的新特性。👉 Python 3.8 有什么新变化？ 它加了一个新特性：仅限位置形参 ( positional-only arguments )。 具体解释如下： ","date":"2023-04-11","objectID":"/strings-replace/:0:0","tags":["python"],"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"仅限位置形参 定义函数的形参时可以指定两个分隔符，分别为/， *。 在下面的例子中，形参 a 和 b 为仅限位置形参，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参。 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 以下均为合法的调用: f(10, 20, 30, d=40, e=50, f=60) 但是，以下均为不合法的调用: f(10, b=20, c=30, d=40, e=50, f=60) # b cannot be a keyword argument f(10, 20, 30, 40, 50, f=60) # e must be a keyword argument 这种标记形式的一个用例是它允许纯 Python 函数完整模拟现有的用 C 代码编写的函数的行为。 例如，内置的 divmod() 函数不接受关键字参数: def divmod(a, b, /): \"Emulate the built in divmod() function\" return (a // b, a % b) 另一个用例是在不需要形参名称时排除关键字参数。 例如，内置的 len() 函数的签名为 len(obj, /)。 这可以排除如下这种笨拙的调用形式: len(obj='hello') # The \"obj\" keyword argument impairs readability 另一个益处是将形参标记为仅限位置形参将允许在未来修改形参名而不会破坏客户的代码。 例如，在 statistics 模块中，形参名 dist 在未来可能被修改。 这使得以下函数描述成为可能: def quantiles(dist, /, *, n=4, method='exclusive') ... 由于在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用: \u003e\u003e\u003e \u003e\u003e\u003e def f(a, b, /, **kwargs): ... print(a, b, kwargs) ... \u003e\u003e\u003e f(10, 20, a=1, b=2, c=3) # a and b are used in two ways 10 20 {'a': 1, 'b': 2, 'c': 3} 这极大地简化了需要接受任意关键字参数的函数和方法的实现。 例如，以下是一段摘自 collections 模块的代码: class Counter(dict): def __init__(self, iterable=None, /, **kwds): # Note \"iterable\" is a possible keyword argument。 还有几个特性： 赋值表达式，也叫海象运算符: :=。 # Loop over fixed length blocks while (block := f.read(256)) != '': process(block) f-string = 用于自动记录表达式和调试文档，也就是加个=直接输出值。 \u003e\u003e\u003e user = 'eric_idle' \u003e\u003e\u003e member_since = date(1975, 7, 31) \u003e\u003e\u003e f'{user=} {member_since=}' ... \"user='eric_idle' member_since=datetime.date(1975, 7, 31)\" 其他的参考官方文档。 参考链接 Python 3.8 有什么新变化 ","date":"2023-04-11","objectID":"/strings-replace/:0:1","tags":["python"],"title":"字符串变量替换","uri":"/strings-replace/"},{"categories":null,"content":"看了很多博主写的文章，感觉解释的不是很详细，本文结合实际操作详细记录了个人对于read、readline、readlines用法的剖解过程。 函数解释及区别 ","date":"2023-04-11","objectID":"/requests/:0:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取全部内容（即不指定n），返回字符串。 函数原型 def read(self, n: int = -1) -\u003e AnyStr: pass 默认读取整个文件，但有以下区别： 返回值的类型是字符串。 读取的最小单位为字符数 最大读取取决于n。 最小读取取决于n。 ","date":"2023-04-11","objectID":"/requests/:1:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取一行内容（即不指定limit）返回一个字符串。 函数原型 def readline(self, limit: int = -1) -\u003e AnyStr: pass 与readlines字面意思一样，也是按行读取，但有以下区别： 返回值的类型是字符串。 最小读取单位为字符数 最小读取取决于limit 最大读取为一行 ","date":"2023-04-11","objectID":"/requests/:2:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取所有内容（即不指定hint），按行返回一个列表，一行内容作为列表的一个元素。 函数原型 def readlines(self, hint: int = -1) -\u003e List[AnyStr]: pass 与readline字面意思一样，也是按行读取，但有以下区别： 返回值的类型是列表。 最小读取单位为行。 最大读取取决于hint。 最小读取为一行。 实际操作 假设有以下文本内容 hello world1 hello world2 hello world3 hello world4 hello world5 hello world6 hello world7 ","date":"2023-04-11","objectID":"/requests/:3:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"read 默认读取 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\nhello world2\\nhello world3\\nhello world4\\nhello world5\\nhello world6\\nhello world7' 一次读取10个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.read(10) if __name__ == '__main__': print(repr(load())) # 输出 'hello worl' ","date":"2023-04-11","objectID":"/requests/:4:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readline 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline() if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 指定一次读取2个字符 def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(2) if __name__ == '__main__': print(repr(load())) # 输出 'he' 指定一次读取15个字符， 可以猜一下输出什么？ hello world1\\nhe? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readline(15) if __name__ == '__main__': print(repr(load())) # 输出 'hello world1\\n' 可以看到并没有将第二行读取进来，也印证了上面我们说： readline 最大读取为一行，最小读取取决于limit。 ","date":"2023-04-11","objectID":"/requests/:5:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"readlines 默认读取(会将行尾的换行符\\n也视为该行一起读取) def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines() if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n', 'hello world3\\n', 'hello world4\\n', 'hello world5\\n', 'hello world6\\n', 'hello world7'] 指定一次读取5个字符，猜一猜输出什么？ ['hello'] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(5) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n'] 并没有。 readlines 最小读取为一行。 指定一次读取15个字符，猜一猜输出什么？ [‘hello world1\\nhe’] ? def load(): path = r'D:\\demo.txt' with open(pa, 'r', encoding='utf-8') as f: return f.readlines(15) if __name__ == '__main__': print(repr(load())) # 输出 ['hello world1\\n', 'hello world2\\n'] 并没有，它读取了两行。 当字符数不够一行时，会将剩余字符一起读进来。所以readlines 的最小读取单位为行。 ","date":"2023-04-11","objectID":"/requests/:6:0","tags":["python"],"title":"python | 详解read、readline、readlines区别","uri":"/requests/"},{"categories":null,"content":"关于我","date":"2019-08-02","objectID":"/about/me/","tags":["关于"],"title":"关于我","uri":"/about/me/"},{"categories":null,"content":"😁关于我 我叫cuckooman。 1996 出生于陕西宝鸡的一个农村家庭，有个妹妹，父母都是很传统的农民，普普通通的四口之家。 目前是一名立志成为全栈工程师的测试开发工程师。主语言为 Python， 也写一些 shell，喜欢Linux、docker。 这是个人在工作之余记录并分享知识的博客，主要涉及测试专业方向，求职简历、一些软件技巧知识、个人生活记录等。 ","date":"2019-08-02","objectID":"/about/me/:0:1","tags":["关于"],"title":"关于我","uri":"/about/me/"},{"categories":null,"content":"🐱‍🚀社交平台 gitee: https://gitee.com/lee_yorke csdn: https://blog.csdn.net/weixin_44200553 个人博客: https://leeyorke.github.io/ ","date":"2019-08-02","objectID":"/about/me/:0:2","tags":["关于"],"title":"关于我","uri":"/about/me/"}]